Got it — you basically want a **lightweight, custom SPM (Strategic Portfolio Management)** tool without all the extra complexity and licensing costs of ServiceNow. We can break this down into **core architecture**, **data model**, and **implementation approach** so your IT team can start building it quickly and scale it later.

---

## 1. Core Features You’ve Described

From what you’ve outlined, the app needs to handle:

* **Entities**

  * **Portfolios** → contain Programs
  * **Programs** → contain Demands & Projects
  * **Demands** → ideas or requests; can convert into Projects
  * **Projects** → initiatives with phases, statuses, PM, etc.
* **Relationships**

  * Portfolio → Program → Project
  * Demand ↔ Project (linked when a demand becomes a project)
* **Lifecycle**

  * Demands & Projects go through defined **phases** (e.g., Idea → Analysis → Delivery) and **statuses** (Active, On Hold, Completed, Cancelled).
* **Roles & Permissions**

  * Users can be:

    * Admin
    * Portfolio Manager
    * Program Manager
    * Project Manager
    * Contributor / Viewer
* **Assignments**

  * Work items (demands/projects) have:

    * Owner
    * Project Manager
    * Team members
* **Basic tracking**

  * Status changes
  * Simple metrics (dates, effort, cost — maybe later)

---

## 2. Suggested Data Model (high-level)

A minimal but flexible relational model could look like this:

**Tables**

* **Users**: id, name, email, role(s)
* **Portfolios**: id, name, description, owner\_id
* **Programs**: id, name, description, portfolio\_id, owner\_id
* **Demands**: id, title, description, program\_id, phase, status, owner\_id, requested\_date
* **Projects**: id, title, description, program\_id, demand\_id (nullable), phase, status, pm\_id, start\_date, end\_date
* **Phases**: id, name, type (demand/project)
* **Statuses**: id, name, type (demand/project)
* **Assignments**: id, project\_id, user\_id, role
* **Audit Log** (optional but useful): id, entity\_type, entity\_id, change\_type, changed\_by, timestamp, details

**Key relationships:**

* **Portfolio → Program → Demand/Project** (one-to-many)
* **Demand → Project** (one-to-one or many-to-one if multiple projects per demand)
* **Users** link to entities via owner/PM or assignments.

---

## 3. Tech Stack Options

Depends on your team’s comfort level:

### **Option A: Fastest MVP (Low-Code/No-Code)**

* **Frontend/Backend**: Retool, Appsmith, or Budibase (internal tools)
* **Database**: PostgreSQL
* **Auth**: Built-in or Auth0
* **Pros**: Weeks not months; easy to iterate
* **Cons**: Less customization in UI/UX

### **Option B: Full Custom Web App**

* **Frontend**: React (Next.js) or Vue (Nuxt.js)
* **Backend**: Node.js (Express, NestJS) or Python (Django, FastAPI)
* **Database**: PostgreSQL or MySQL
* **Auth**: Auth0, Supabase Auth, or custom JWT
* **Pros**: Maximum flexibility; easier to integrate with other systems
* **Cons**: More dev time & maintenance

### **Option C: Hybrid**

* Backend API + Admin UI in low-code tool, custom UI for end users.

---

## 4. Implementation Roadmap

**Phase 1 (MVP)** — Core entities & CRUD

* User authentication & role-based access
* Create/view/edit portfolios, programs, demands, projects
* Phase & status management
* Owner/PM assignment
* Basic reporting list views

**Phase 2** — Usability & Tracking

* Search & filtering
* Audit log for changes
* Dashboard widgets (active projects, demands by status)

**Phase 3** — Nice-to-have features

* File attachments
* Comments & collaboration
* Basic Gantt chart view for projects
* API integrations (Jira, Teams, email notifications)

---

I can diagram the **entity-relationship model** for you so it’s crystal clear before you start coding — that way, you avoid rework later.

Do you want me to go ahead and draft that ERD for the portfolios–programs–demands–projects relationships with roles and phases? That would lock in your data model before the build.
